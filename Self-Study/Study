Chap 01. C++ 시작
	기계어 - 0, 1만의 이진수를 사용하는 가장 원시적인 언어.
	고급언어 - 사람이 이해하고 표현하기 쉬우며, 복잡한 알고리즘이나 다양한 프로그램 구조 및 자료를 효율적으로 표현하는 언어.

	C언어에 추가한 기능
		1. 함수 중복 - 매개 변수의 개수나 타입이 서로 다른 동일한 이름의 함수들을 선언할 수 있음.
		2. 디폴트 매개 변수 - 매개 변수에 값이 전달되지 않는 경우 디폴트 값이 전달되도록 함수를 선언할 수 있음.
		3. 참조와 참조 변수 - 변수에 별명을 붙여 변수 공간을 같이 사용할 수 있는 참조의 개념을 도입.
		4. 참조에 의한 호출 - 함수 호출시 참조를 전달할 수 있게 함.
		5. new와 delete 연산자 - 동적 메모리 할당, 해제를 위한 new, delete 연산자를 도입.
		6. 연산자 재정의 - 기존의 연산자에 새로운 연산을 정의할 수 있음.
		7. 제네릭 함수와 클래스 - 함수나 클래스를 데이터 타입에 의존하지 않고 일반화시킬 수 있음.

	C++의 객체 지향 특성
		1. 객체와 캡슐화 - 캡슐화란 객체의 구성 요소들을 캡슐로 싸서 외부의 접근으로부터 내부 요소들을 보호하는 객체 지향 특성.
			1) 캡슐의 역할을 하는 것 - 클래스.
			2) 클래스 - 객체를 정의하는 틀 혹은 설계도, 클래스에 멤버 변수와 멤버 함수를 선언.
			3) 객체 - 클래스라는 틀에서 생겨난 실체, 멤버 변수 메모리와 멤버 함수 코드를 실제 가지고 프로그램이 실행되는 동안 실존하는 실체 혹은 인스턴스.(클래스로 무언가를 만든것이 객체)
					하나의 클래스로 여러 개의 객체를 생성 가능.
		2. 상속성 - 객체를 정의하는 클래스 사이에 상속 관계를 두어, 자식 클래스의 객체가 생성될 때 자식 클래스에 선언된 멤버뿐 아니라 부모 클래스에 선언된 멤버들도 함께 가지고 탄생하게 함.
		3. 다형성 - 하나의 기능이 경우에 따라 서로 다르게 보이거나 다르게 작동하는 현상.
				연산자 중복 - 더하기 연산자(+)가 정수 덧셈, 문자열 연결, 객체 더하기 등 피연산자에 따라 서로 다른 연산이 적용.
				함수 중복 - 같은 이름의 함수가 매개변수의 개수나 타입이 다르면 서로 다른 함수로 인식.
					함수 재정의 / 함수 오버라이딩 - 부모 클래스에 구현된 함수를 동일한 이름으로 자식 클래스에서 다르게 구현.

	절차 지향 프로그래밍 - 실행하고자 하는 절차대로 일련의 명령어를 나열하여 프로그래밍 하는 방법. (C 언어)
	객체 지향 프로그래밍 - 프로그램을 보다 실제 세상에 가깝게 모델링하여 실제 세상의 물체를 객체로 표현. 그리고 객체들의 관계, 상호 작용을 객체 지향 기법으로 구현. (C++ 언어)

	컴파일 - 컴파일러는 개발자가 작성한 소스 프로그램이 문법이 맞게 작성되었는지 검사하고, 기계어 코드로 변환하여 목적파일을 생성. 만약 문법에 맞지 않게 작성된 코드를 발견하면 컴파일 오류를 발생.
	링킹 - 실행에 필요한 모든 기계어 코드를 확보하고, 하나의 실행 파일로 만들어지는 과정.
	디버깅 - 프로그램 내에 오류 위치를 발견하거나 문제의 원인을 찾아 수정하는 과정.

Chap 02. C++ 프로그래밍의 기본
	main() 함수
		C 언어와 마찬가지로 C++ 언어 프로그램의 실행 시작점.(종료하면 프로그램이 종료 / return 문 생략 가능)

	cout 객체 - 스크린 장치와 연결된 C++ 표준 출력 스트림 객체.
		<< 연산자 - 스트림 삽입 연산자라고 불리며, 오른쪽 피 연산자를 왼쪽 스트림 객체에 삽입.
	cin 객체 - 키보드와 C++ 응용프로그램을 연결하는 C++ 표준 입력 스트림 객체.
		>> 연산자 - 스트림 추출 연산자라고 불리며, 왼쪽 피 연산자인 스트림 객체로부터 데이터를 읽어 오른쪽 피연산자에 지정된 뱐수에 삽입.

	cin.getline(char buf[], int size, char delimitichar)
		buf : 키보드로부터 읽은 문자열을 저장할 배열
		size : buf[] 배열의 크기
		delimitichar(생략가능, 디폴트 값:'\n') : 문자열 입력 끝을 지정하는 구분 문자
				EX) cin.getline(name, 100, \n) : <ENTER> 키가 입력될 때까지 최대 99개의 문자 입력. 띄어쓰기도 읽어줘서 "안 세준" 입력. name은 '안'이 아닌 "안 세준"

Chap 03. 클래스와 객체
	[클래스 선언부]
		class 클래스명 {
		접근지정자:
			--- 
		};

	[클래스 구현부]
		리턴타입 클래스명::함수명(매개변수) {
			return ---; 
		}

	[객체 생성]
		클래스명 객체명
			>> 원하는 객체명으로 객체 생성.

	[객체 멤버 접근]
		객체명.멤버

	생성자란? 클래스가 객체를 생성할 때 자동으로 호출되는 생성자. 특별한 멤버 함수를 넣어 객체를 초기화.
	사용 목적. 객체가 생성될 때 필요한 초기 작업을 위함.
	특징.1) 생성자 함수가 중복이더라도 해당되는 함수 한 번만 실행됨.
		2) 생성자 함수의 이름은 클래스 이름과 동일하게 작성.
		3) 생성자 함수의 원형에 리턴 타입을 선언하지 않음.
		4) 생성자는 한 클래스에 여러 개 만들 수 있음.

	위임 생성자란? 객체의 초기화 작업이 코딩된 생성자를 타겟 생성자.
	생성자는 객체의 초기화를 다른 생성자에 위임한는 생성자가 위임 생성자.

	생성자는 객체가 생성될 때 반드시 있어야하며 생성자가 없는 클래스에 대해서는, 컴파일러가 기본 생성자를 만들어 삽입.
	기본 생성자란? 클래스 내에 선언된 생성자가 하나도 없을 때 컴파일러가 자동으로 생성해주는 생성자. 만약, 클래스 내에 생성자가 하나라도 선언되었을 경우, 컴파일러는 기본 생성자를 자동 삽입하지 않음.

	소멸자란? 객체가 소멸되는 시점에서 자동으로 호출되는 클래스의 멤버 함수.
	[소멸자]
		~ 클래스명();

	사용 목적. 객체가 사라질 때 필요한 마무리 작업을 하기 위함.
	특징.1) 소멸자의 이름은 클래스 이름 앞에 ~를 붙임.
		2) 소멸자의 리턴 타입은 없으며, 어떤 값도 리턴해서도 안됨.
		3) 소멸자는 생성자와 달리 오직 한 개만 존재하며 매개변수를 가지지 않음.
		4) 소멸자가 선언되어 있지 않으면 기본 소멸자가 자동으로 생성.

	생성자/소멸자 실행 순서
		지역 객체 - 함수 내에서 선언된 객체
			함수가 실행될 때 생성되고, 함수가 종료할 때 소멸.
		전역 객체 - 함수 바깥에 선언된 객체
			프로그램이 로딩될 때 생성되고, main()이 종료한 뒤 프로그램 메모리가 사라질 때 소멸.
		지역 객체나 전역 객체 모두 생성된 순서의 반대순으로 소멸.

	접근 지정자
		private(디폴트 접근 지정) - 클래스 내의 멤버 함수들에게만 접근 가능 / 멤버 변수는 private으로 지정하는 것이 바람직.
		public - 클래스 내외를 막론하고 프로그램의 모든 함수들에게 접근 허용 / 클래스 외부에서 객체를 생성하기 위해서는 생성자를 public으로 선언해야 함.
		protected - 클래스 내의 멤버 함수와 해당 클래스를 상속받은 파생 클래스의 멤버 함수에게만 접근 허용.

	인라인 함수란? 짧은 코드로 구성된 함수에 대해, 함수 호출 오버헤드로 인한 프로그램의 실행 속도 저하를 막기 위해 도입된 기능.
	[인라인 함수로 선언]
		inline 리턴타입 함수명(매개변수) { --- }

	사용 목적. 함수 호출 오버헤드가 없어져 실행 속도가 빨라짐.
	장점. 프로그램의 실행 속도를 향상시킬 수 있음.
	단점. 호출하는 곳이 여러 군데 있으면 그 만큼 전체 코드가 늘어남.
	자동 인라인 : 클래스의 선언부에 구현된 멤버 함수들에 대해서 inline 선언이 없어도 인라인 함수로 자동 처리.

	구조체 : C 구조체에 기능을 확장하여 클래스와 동일한 구조와 기능.
	[구조체 선언]
		struct 구조체명{
			디폴트 접근 지정자 : public:
		}

	[구조체 객체 생성]
		구조체명 객체명;
			C++ 에서는 구조체의 객체를 생성할 때 struct 키워드를 붙이지 않음.

	클래스와 구조체의 차이점
		클래스의 디폴트 접근 지정자 : private
		구조체의 디폴트 접근 지정자 : public

Chap 04. 객체 포인터와 객체 배열, 객체의 동적 생성
	[객체에 대한 포인터 변수 선언]
		클래스명 *포인터변수;

	[포인터 변수에 객체 주소 지정]
		포인터변수 = &객체명

	[변수 선언과 초기화]
		클래스명 *포인터변수 = &객체명

	[접근방법]
		객체 이름으로 멤버를 접근할 때 ' . ' 연산자를 이용하였지만, 객체 포인터로 멤버를 접근할 때 ' -> ' 연산자를 이용.

	[객체 배열 선언]
		클래스명 배열명[정수];
			> 배열은 정수개의 클래스가 만든 객체를 원소로 가지는 배열.
	객체 배열 선언문은 기본 생성자를 호출. 만약, 기본 생성자가 선언되어 있지 않으면 컴파일 오류 발생.

	[객체 배열 사용]
		배열명[원하는 배열 인덱스].함수명();

	[객체 배열의 소멸자]
			각 원소 객체마다 소멸자가 호출되고, 높은 인덱스에서부터 원소 객체가 소멸.

	[동적 메모리 할당 및 반환]
		데이터타입 *포인터변수 = new 데이터타입;
		delete 포인터변수;
			C 에서는 malloc()/free() 등 표준 C 함수를 사용하였지만, C++ 에서는 new/delete 연산자를 사용.
			new 연산자는 힙이라는 공간으로 메모리를 할당, delete 연산자는 할당받은 메모리를 힙으로 반환.


	[배열의 동적 메모리 할당 및 반환]
		데이터타입 *포인터변수 = new 데이터타입[배열의 크기];
		delete [] 포인터변수;

	[객체의 동적 메모리 할당 및 반환]
		클래스이름 *포인터변수 = new 클래스이름; //클래스이름(생성자매개변수리스트);
		delete 포인터변수;

	[객체 배열의 동적 메모리 할당 및 반환]
		클래스이름 *포인터변수 = new 클래스이름[배열의 크기];
		delete [] 포인터변수;
			각 원소 객체마다 소멸자가 호출되고, 높은 인덱스에서부터 원소 객체가 소멸.

	this의 기본
		this는 객체 자신의 대한 포인터로서 클래스의 멤버 함수 내에서만 사용.

	this와 객체
		this는 객체 자신에 대한 포인터.

	this가 사용되는 경우
		1. 멤버 변수의 이름과 동일한 이름으로 매개 변수 이름을 짓고자하는 경우.
		2. 멤버 함수에서 객체 자신의 주소를 리턴 할 때.
		
	this의 제약조건
		1. 클래스의 멤버 함수에서만 사용.
		2. 정적 멤버 함수(static member function)는 사용할 수 없음.

	string 클래스에 있는 문법들
	ex.	string name = "sejoon"
		string names = "sejun"
		
		[getline(cin, string객체, '끝을 알리는 문자')]
			- '끝을 알리는 문자'가 올때까지 입력된 문자들을 string객체에 문자열로 저장.

		[compare() 함수]
			int 변수 = name.compare(names);
				name과 names가 같으면 변수에 0을, name이 앞에 오면 음수를, 뒤에 오면 양수를 리턴.

		[append() 함수]
			name.append(" is man");
				"sejoon is man" 출력.

		[insert() 함수]
			name.insert(0, "Ahn ");
				"Ahn sejoon" 출력.

		[replace() 함수]
			name.replace(3, 4, "u");
				"sejun" 출력.

		[length(), size() 함수]
			int len = name.length();
			int sizes = name.size();
				두 개 다 동일하게 '6' 출력.

		[erase(), clear() 함수]
			name.erase(0, 3);	//처음부터 3개의 문자 삭제
				"joon" 출력 > erase() 함수는 일부분을 삭제.
			name.clear();
				"" 출력 >  clear() 함수는 완전히 삭제.

		[substr() 함수]
			string n = name.substr(2, 4);	//index 2부터 4개의 문자 리턴
				"joon" 출력.

		[find() 함수]
			int index = name.find("joon");	//name에서 "joon" 검색. index = 2
			index = name.find("jun");		//name에서 "jun"을 찾을 수 없음. index = -1

		[at() 함수]
			char c1 = name.at(2);
			char c2 = name[2];
				둘 다 동일한 표현. 'j' 리턴.

		[stoi() 함수]
			string year = "2000";
			int y = stoi(year);
				y은 정수 2000 값.

Chap 05. 함수와 참조, 복사 생성자
	1. 값에 의한 호출 - 코드에서 넘겨주는 실인자 값이 함수의 매개 변수에 복사되어 전달되는 방식.
		장점. 함수 내에서 실인자(원본 객체)를 손상 시킬 수 없음.
		문제점. 매개 변수 객체의 생성자는 실행되지 않고, 소멸자만 실행. (비대칭 구조)

	2. 주소에 의한 호출 - 주소를 직접 포인터 타입의 매개 변수에 전달받는 방식. (배열의 이름은 곧 배열의 주소)
		의도적으로 함수 내에서 실인자의 값을 변경하고자 할 때 이용.
		특징. 생성자나 소멸자가 실행되지 않음. 값에 의한 호출에 비해 원본 객체를 복사하는 시간 소모가 없으며, 매개 변수가 단순 포인터.

	객체 치환
		동일한 클래스 타입에 대해서만 적용되고, 치환시 내용물만 같을 뿐 별개임.

	참조 개념 - 선언된 변수에 대한 별명.
		참조 변수 = '&' 기호 (참조자라고 불림)
		[참조 선언]
		자료형 & 참조변수 = 이미 선언 된 변수

		주의할 점.	1) 선언 시 반드시 원본 변수로 초기화 해야함. (초기화가 없으면 컴파일 오류)
				2) '&'(참조자)의 위치가 무관. (자료형과 참조변수 사이에만 작성되면 됌)
				3) 참조 변수의 배열을 만들 수 없음.
				4) 참조 변수에 대한 참조 선언이 가능.

		특징. 참조 변수가 선언될 시, 참조 변수 이름만 생성되며, 별도의 공간이 할당되지 않음. 대신. 참조 변수는 초기화로 지정된 원본 변수의 공간을 공유.

	3. 참조에 의한 호출 - 함수의 매개 변수를 참조 타입으로 선언하여, 매개 변수가 함수를 호출 하는 쪽의 실인자를 참조하여 실인자와 공간을 공유하도록 하는 인자 전달 방식.
		참조 매개 변수 - 참조 타입으로 선언된 함수의 매개 변수.
		참조 매개 변수는 위 참조와 동일하게 이름만 존재하며 스택에 공간을 따로 할당 받지 않음.

	장점. 간단히 변수를 넘겨주기만 하면 되고, 함수 내에서도 참조 매개 변수를 보통 변수처럼 사용하기 때문에 작성하기 쉽고 보기 좋은 코드가 됨.

	참조 매개 변수로 이루어진 모든 연산은 원본 객체에 대한 연산.
	참조 매개 변수는 이름만 생성되므로, 생성자와 소멸자는 아예 실행되지 않음.

	참조 리턴 - 변수 등과 같이 현존하는 공간에 대한 참조의 리턴.

	복사 생성자란? 복사 생성 시에만 실행되는 특별한 생성자.
		매개 변수는 오직 하나이며, 자기 클래스에 대한 참조로 선언. 또한, 클래스에 오직 한 개만 선언할 수 있음.

		[복사 생성자 선언]
			class 클래스명 {
				클래스명(const 클래스명& 변수명);	//복사 생성자
			};

	디폴트 복사 생성자란? 클래스가 복사 생성자를 가지고 있지 않을 때, 실행되는 복사 생성자. / 얕은 복사를 실행하도록 만들어짐.

	ex.	class Person {
			int id;
			char *name;
		}

		얕은 복사 - 원본 객체의 id와 name 멤버는 현재 상태 그대로 사본 객체에 복사되므로, 사본의 name은 원본의 name메모리를 공유함.
		Person(const Person& person){
			this->id = person.id;
			this->name = person.name;
		}
			원본 객체의 모든 멤버를 일대일로 사본에 복사하도록 구성. / 포인터 타입의 멤버 변수가 없는 클래스는 얕은 복사도 전혀 문제가 되지 않음.
			문제점. 원본 객체의 포인터 멤버 변수가 사본 객체의 포인터 멤버 변수에 복사되면, 이 둘은 같은 메모리를 가리키게 되어 심각한 문제 발생. 사본 객체의 name을 변경하면 원본 객체의 name 문자열이 변경되는 문제가 발생.
			소멸자 순서는 생성된 객체 반대 순으로 소멸, 같은 메모리를 반환하기에 이미 반납한 메모리를 다시 반납하여, 비정상 종료.

		깊은 복사 - 원본의 name 포인터가 가리키는 메모리까지 복사하여 원본과 사본의 name은 별개의 메모리를 가리킴.
		Person(const Person& person){
			this->id = person.id;
			int len = strlen(person.name);		//name의 문자 개수
			this->name = new char [len + 1];	//name을 위한 공간 할당
			strcpy(this->name, person.name);	//name의 문자열 복사
		}

Chap 06. 함수 중복과 static 멤버
	함수 중복 조건.
		1. 중복된 함수들의 이름이 동일하여야 함.
		2. 중복된 함수들은 매개 변수 타입이나 매개 변수의 개수가 달라야 함.
		3. 함수 중복에 리턴 타입은 고려되지 않음.

	성공 사례.
		int sum(int a, int b, int c)	//매개 변수가 3개
			return a + b + c;

		int sum(double a, double b)		//매개 변수가 타입이 다름
			return a + b;

		int sum(int a, int b)			//매개 변수가 2개
			return a + b;

	실패 사례.
		int sum(int a, int b)
			return a + b;

		double sum(int a, int b)
			return a + b;

		함수 이름이 같지만, 매개 변수 개수 / 타입이 같아 실패. return 값은 영향을 안줌.

	생성자 함수도 중복 가능. 객체를 생성할 때 매개 변수를 통해 다양한 형태로 초깃값을 전달하기 위해 생성자 함수를 중복 선언.
	소멸자는 매개변수를 갖지 않기 때문에 한 클래스에 오직 하나만 존재.

	디폴트 매개 변수 - 매개 변수에 값이 넘어오지 않는다면, 미리 정해진 디폴트 값을 받도록 선언된 매개 변수.
	[선언 방법]
		'매개 변수 = 디폴트 값'

	ex. void square(int width = 1, int height = 1);	//width, height의 디폴트 값 1
		square();		//square(1, 1); 와 동일.
		square(10);		//square(10, 1); 와 동일.	매개변수 width에 10 전달
		square(3, 8);	//square(3, 8); 와 동일.	매개변수 width에 3, height에 8 전달

	디폴트 매개 변수의 제약조건
		1. 모두 끝 쪽에 몰려 선언되어야 함. / 모두 오른쪽 끝에 몰려 선언.
			함수 호출문에 나열된 실인자 값들을 앞에서부터 순서대로 함수의 매개 변수에 전달하고 나머지는 디폴트 값으로 전달.

	함수 중복의 모호성
		1. 형 변환으로 인한 모호성.
		2. 참조 매개 변수로 인한 모호성.
		3. 디폴트 매개 변수로 인한 모호성.
